* I need to keep the documentation up to date. Namely, the GDD is getting out of date.
* How many lookups is the map system using?
* Add the serial packet to the network utility
* I completely forgot about status ailments

--Naming conventions--

I need to define the differences between several different terms i.e. naming conventions.
I may also need to rewrite some variable names.

* User: This is the individual who is playing the game
* Player: A synonym for a user
* Character: This is the actual player character in the game
* Username: This is the name of the player; ususally kept private
* Handle: This is the name of a character
* Avatar: This is the name of the sprite used by a character

--ServerApplication's methods--

//NOTE: I honestly don't know what I'm doing
CreateCombatInstance(roomIndex)
PushCharacterToCombat(charIndex, combatIndex)
UpdateCombatInstances() //handles all combat

--Battle System--

CharacterData:
	--stats

EnemyData
	--stats

CombatInstance
	list<CharacterData*>
	list<EnemyData>

Room:
	RegionPager pager
	EnemyFactory enemyFactory --this takes information on the room's data early in the room's construction
	list<CombatInstance>

--Requirements--

The enemies need AI scripts
The scripts need to be able to generate other enemies (frog king).
The characters need a flag to show if they're in a combat instance or not, to signify of they should be unloaded client-side
On each game loop, the server should envoke each combat instance's update function
	Each combat instance invokes each enemy's and character's update functions
		These update functions increase the ATB guagues
		if an ATB guage is full
			than the stored command is executed
			the players issue their commands during the build up
			if there isn't a command ready, then the player is still choosing
			for the enemies, the stored commands are driven by scripts, so when the enemies need to attack, their attached scripts are called.
		after the commands are called, the ATB is reset to 0.
	etc...

--Enemy Tables--

enemyTables: The global store of enemy tables. Only accessed by C++ code (unless you want to break something).

table.logic: the AI logic. If null, simply attack
table.ref: reference to the enemy itself, for use by API functions, set by constructor?







--NOTE: useful for copying tables
function deepcopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[deepcopy(orig_key)] = deepcopy(orig_value)
        end
        setmetatable(copy, deepcopy(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end